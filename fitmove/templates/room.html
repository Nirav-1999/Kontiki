<!-- chat/templates/chat/room.html -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic@0.1/holistic.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <title>Chat Room</title>
</head>

<style>
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  .abs {
    position: absolute;
  }
  
  a {
    color: white;
    text-decoration: none;
    &:hover {
      color: lightblue;
    }
  }
  
  body {
    bottom: 0;
    font-family: 'Titillium Web', sans-serif;
    color: white;
    left: 0;
    margin: 0;
    position: absolute;
    right: 0;
    top: 0;
    transform-origin: 0px 0px;
    overflow: hidden;
  }
  
  .container {
    /* position: absolute; */
    float: left;
    background-color: #596e73;
    height: 100vh;
    width: 50vw;
  }

  .container_new {
    /* position: absolute; */
    float: left;
    background-color: #596e73;
    height: 100vh;
    width: 50vw;
  }
  
  .input_video {
      
    display: none;
    position:relative;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 50vw;
    height: 100vh;
    &.selfie {
      transform: scale(-1, 1);
    }
  }
  
  .second_video{
      display: none;
  }
  .output_canvas {
    position:absolute;
    height: 100vh;
    width: 50vw;
    left: 0;
    top: 0;
  }

  .output_canvas_second {
    /* position:absolute; */
    height: 100vh;
    width: 50vw;
    left: 0;
    top: 0;
  }
  
  .logo {
    bottom: 10px;
    right: 20px;
  
    .title {
      color: white;
      font-size: 28px;
    }
  
    .subtitle {
      position: relative;
      color: white;
      font-size: 10px;
      left: -30px;
      top: 20px;
    }
  }
  
  .control-panel {
    position: absolute;
    left: 10px;
    top: 10px;
  }
  
  .loading {
    display: flex;
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    align-items: center;
    backface-visibility: hidden;
    justify-content: center;
    opacity: 1;
    transition: opacity 1s;
  }
    .message {
      font-size: x-large;
    }
  
    .spinner {
      position: absolute;
      width: 120px;
      height: 120px;
      animation: spin 1s linear infinite;
      border: 32px solid #bebebe;
      border-top: 32px solid #3498db;
      border-radius: 50%;
    }
  
  
  .loaded .loading {
    opacity: 0;
  }
  
  .shoutout {
    left: 0;
    right: 0;
    bottom: 40px;
    text-align: center;
    font-size: 24px;
    position: absolute;
  }
  
</style>

<body>

    {{ room_name|json_script:"room-name" }}

    <div class="container">

       <video class="input_video"></video>

        <canvas class="output_canvas" ></canvas>
        <div class="loading">
        <div class="spinner"></div>
        <div class="message">
            Loading
        </div>
        </div>
    
        
    </div>
    <div class="container_new">

        <video class="second_video"></video>

        <canvas class="output_canvas_second" ></canvas>
        <div class="loading">
        <div class="spinner"></div>
        <div class="message">
            Loading
        </div>
        </div>
    
        
    </div>
    <div class="control-panel"></div>

    <script>

        // Our input frames will come from here.
        const videoElement = document.getElementsByClassName('input_video')[0];
        // console.log(videoElement)
        const canvasElement = document.getElementsByClassName('output_canvas')[0];
        const canvasElementSecond = document.getElementsByClassName('output_canvas_second')[0];
        // console.log(canvasElementSecond)
        const controlsElement = document.getElementsByClassName('control-panel')[0];
        // console.log(controlsElement)
        const canvasCtx = canvasElement.getContext('2d');
        const canvasCtxSecond = canvasElementSecond.getContext('2d');

        const roomName = JSON.parse(document.getElementById('room-name').textContent);

        const chatSocket = new WebSocket(
            'wss://'
            + window.location.host
            + ':8001/ws/video/'
            + roomName
            + '/'
        );
        console.log(chatSocket)       
 
        function sleep(ms) {
          return new Promise(resolve => setTimeout(resolve, ms));
        }

        chatSocket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            count += 1;
            console.log(data.message)

            canvasCtxSecond.beginPath();
            console.log("Message Incoming");
            

            drawConnectors(
                canvasCtxSecond, data.message, POSE_CONNECTIONS,
                {color: '#ffffff', lineWidth: 2});
        
            // canvasCtxSecond.stroke();
            
            // canvasCtxSecond.clearRect(0, 0, canvasElementSecond.width, canvasElementSecond.height)

            // console.log(data)
        };

        chatSocket.onclose = function(e) {
            console.error('Chat socket closed unexpectedly');
        };

 

        // console.log(canvasCtx)
        // console.log(canvasCtxSecond)


        // We'll add this to our control panel later, but we'll save it here so we can
        // call tick() each time the graph runs.
        // const fpsControl = new FPS();

        // Optimization: Turn off animated spinner after its hiding animation is done.
        const spinner = document.querySelector('.loading');
        spinner.ontransitionend = () => {
        spinner.style.display = 'none';
        };

        // function find_angle(A,B,C) {
        //     var AB = Math.sqrt(Math.pow(B.x-A.x,2)+ Math.pow(B.y-A.y,2));    
        //     var BC = Math.sqrt(Math.pow(B.x-C.x,2)+ Math.pow(B.y-C.y,2)); 
        //     var AC = Math.sqrt(Math.pow(C.x-A.x,2)+ Math.pow(C.y-A.y,2));
        //     return Math.acos((BC*BC+AB*AB-AC*AC)/(2*BC*AB));
        // }

        var count = 0;
        // var f = 1;

        function onResults(results) {

        // Hide the spinner.
        document.body.classList.add('loaded');
        //   console.log(results.poseLandmarks)

        // Update the frame rate.
        //   fpsControl.tick();

        // Draw the overlays.
        // console.log(results)
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        canvasCtx.drawImage(
            results.image, 0, 0, canvasElement.width, canvasElement.height);
        
        // console.log(canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height))

        canvasCtxSecond.save();

        canvasCtxSecond.clearRect(0, 0, canvasElementSecond.width, canvasElementSecond.height)

        
        // canvasCtxSecond.drawImage(
        //     results.image, 0, 0, canvasElementSecond.width, canvasElementSecond.height);
        // console.log(canvasCtxSecond.clearRect(0, 0, canvasElementSecond.width, canvasElementSecond.height));


        // var angleRight  = find_angle(results.poseLandmarks[23],results.poseLandmarks[25],results.poseLandmarks[27])*180/Math.PI
        // var angleLeft = find_angle(results.poseLandmarks[24],results.poseLandmarks[26],results.poseLandmarks[28])*180/Math.PI
        
        // if ( (angleRight >= 170  && angleLeft >= 170 ) && f == 1 ){
        //     count += 1;  
        //     f = 0;
        //     console.log("Flgged")
        // }


        // console.log(results.poseLandmarks)
        // if ( (angleRight >= 70 && angleRight <=110) && (angleLeft >= 70 && angleLeft <= 110) ){
            // drawConnectors(
            //     canvasCtx, results.poseLandmarks, POSE_CONNECTIONS,
            //     {color: '#ffffff', lineWidth: 2});

            chatSocket.onopen = () => {
	    	console.log("Connection Established");
	    }
	   
	   if (chatSocket.readyState == 1){
		console.log("Sending message...");
	   	chatSocket.send(JSON.stringify({
                        'points': results.poseLandmarks,
                }));

           } 

                // console.log(angleRight)
                // console.log(angleLeft)
        //     f = 1;
            

        // }
        // else{
        //     drawConnectors(
        //         canvasCtx, results.poseLandmarks, POSE_CONNECTIONS,
        //         {color: '#ffffff'});
            

        // }
        canvasCtx.fillStyle = "blue";
        canvasCtx.font = "bold 16px Arial";
        // canvasCtx.fillText("AngleRight = " + angleRight, 20, 60);
        // canvasCtx.fillText("AngleLeft = " + angleLeft, 20, 80);
        
        // console.log(count)
        // canvasCtx.fillText("Count = " + (count - 1), 20, 100);


        
        // drawLandmarks(
        //     canvasCtx, results.poseLandmarks,
        //     {color: '#00FF00', fillColor: '#FF0000', lineWidth: 1, radius: 1});
        canvasCtx.restore();
        canvasCtxSecond.restore();





        }

        const pose = new Pose({locateFile: (file) => {
            // console.log(file);
        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.1/${file}`;
        }});
        pose.onResults(onResults);

        /**
         * Instantiate a camera. We'll feed each frame we receive into the solution.
         */
        const camera = new Camera(videoElement, {
        
        onFrame: async () => {
            // console.log("Await start");

            await pose.send({image: videoElement});
            await sleep(30)
            
            // console.log("Await end");
        },
        // width: 1280,
        // height: 720
        });
        // console.log("Camera start");

        camera.start();

        // Present a control panel through which the user can manipulate the solution
        // options.
        new ControlPanel(controlsElement, {
            selfieMode: true,
            upperBodyOnly: false,
            smoothLandmarks: true,
            minDetectionConfidence: 0.3,
            minTrackingConfidence: 0.3
            })
            .add([
            new StaticText({title: 'MediaPipe'}),

            ]);
        

        



    </script>
</body>
</html>
